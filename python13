# from Crypto.Util.number import long_to_bytes
# from gmpy2 import invert
# from gmpy2 import powmod
#
# # 题目中给出的c的值
# c = 288583678735049371919673340730418228485477940310741339914624217819529276681225495075376391651261205509328226859631846793053201460235010488297587596269937924218956477735719503225536564421346664301252559438377649598272486105046347030702708557982827370366079349136251313390524857338362073665538355470509401897360463540702070068961569451047841147736337319782489097918108953232237896483570220212906554019074695597505152267700787501593388716395879944029055882427504231399799721015834495220738683966127722440310998658593224685491375724487741866371846108025669314070759275296463678058719957044861982876127216717624970757345076602865951704573525267699728049039491214929746992648569328732091353557452849477807683208861494550503135279129232300433367729170768384535490549837594597370735352519041368897712455573865221456850567492498703241386380289633335230898
#
# Prime_list = [
#         64338049618531666637299822994925386283398104046319742997534172999904394041493,
#         63797254679645335051320814987520304515647409786931705859898588909986556832581,
#         78097730786597117446449535914520424445511265346191323846148194405252882554833,
#         91649930808939807602461200139193189695253449203183199245681642998983554801013,
#         96835791514480348436873814832245222010334540574138563964769782393947536249261,
#         113799811273592751066219197902836913919143597021131851742310968287268579054263,
#         92449046808638024903167928323968303912388690158869263349729164310111275350413,
#         90680943735745053918563227831303823567870043933794290530842025289216143785867,
#         84617907288638973056166199326153655706904365084437459353777480505896479483453,
#         92427145706222547306905159763398020274316679495725138413730192588320485530637,
#         106570010815784909361830452803097888701816976400010215028255429537589954023857
# ]
#
# n = 1
# for prime in Prime_list:
#     n *= prime
#
# phi_n = 1
# for prime in Prime_list:
#     phi_n *= (prime - 1)
#
# e = 65537
# d = invert(e, phi_n)
# m = powmod(c, d, n)
# flag = long_to_bytes(m)
# print(flag)

#------------------------------
#
# from Crypto.Util.number import long_to_bytes
# from gmpy2 import is_prime, invert, powmod
#
# # 题目中给出的已知值
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 求解p
# for r in range(e, 2 * e + 1):
#     candidate_p = hint - e ^ r
#     if is_prime(candidate_p):
#         p = candidate_p
#         break

# def encrypt(text):
#     if not isinstance(text, str) or len(text) == 0:
#         raise ValueError("输入的text参数必须是非空字符串")
#     encrypted = []
#     for char in text:
#         ascii_code = ord(char)
#         a = 3 if ascii_code % 2!= 0 else 127
#         encrypted_char = (a * ascii_code + b) % m
#         encrypted.append(encrypted_char)
#     return encrypted
# # 计算q
# q = n // p
#
# # 计算私钥指数d
# phi_n = (p - 1) * (q - 1)
# d = invert(e, phi_n)
#
# # 还原消息m并获取flag
# m = powmod(c, d, n)
# flag = long_to_bytes(m)
# print(flag)

from Crypto.Util.number import *
from gmpy2 import *
import random

# 读入题目给出的输出值
c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
e = 65537

# 穷举可能的随机数范围，尝试求出p
for i in range(e,2*e):
    p=(hint^i)-e
    q = n//p
    try:
        d = invert(e,(p-1)*(q-1))
        m = long_to_bytes(pow(c,d,n))
        if b'FLAG' in m:
            print(m)
            break
    except:
        pass
# 
# 代码功能概述
# 这段 Python 代码旨在解决一个与 RSA 加密相关的密码学问题，通过已知的密文c、模数n、公钥指数e以及一个包含额外信息的hint值，尝试还原出原始的明文（预期是包含FLAG字样的字节串，代表题目中的flag）。其主要思路是通过穷举hint中涉及的随机数可能值，进而求出私钥相关参数来解密密文。
# 代码详细分析
# 循环穷举部分：
# python
# for i in range(e, 2*e):
#     p = (hint ^ i) - e
#     q = n // p
# 这里通过一个for循环，在range(e, 2*e)这个范围内（也就是从公钥指数e到2 * e之间的值），利用异或运算结合已知的hint和e来尝试计算出可能的p值，然后根据n = p * q，通过整除运算计算出对应的q值。


#
# result_bytes = b"&D\xc6\x0b\xbb!\x04K\xb0\xf1\xde\xeb\xbaF\ne\x95&\xf7\x96)=\x8a/;\x19\xe3\xd9\xee\x9a\xe6\x81\xd2\x1d\x9ck\xab\x81r[\xbc\xb9\x83\xb6\x07\x97\xdcg\xad\xcc\xc4KL(\t\x84\xbf\xba3\xe8\x14\xd3P\xe3\xfc\xb6I\x87\xc5\x9d\xc8\x842\x96\x82\xca]\x84L\xact\x06\x01\x84\xc5\x07C\xaa\xd2jf\\\xe6\xc2\xd9\x04\xcc\xc0\xb0\xb1\xfe\x11J\xe0'\x0b\xdf\x16\x02\xd6\x1d\x9d2+\x90@1\xdd\xb2\xf8 O^\xfb\x7f-\x94\x1a"
# try:
#     result_str = result_bytes.decode('utf-8')
#     print(result_str)
# #except UnicodeDecodeError:
#  #   print("可能不是utf-8编码，尝试其他编码进行解码查看")

# result_bytes = b"&D\xc6\x0b\xbb!\x04K\xb0\xf1\xde\xeb\xbaF\ne\x95&\xf7\x96)=\x8a/;\x19\xe3\xd9\xee\x9a\xe6\x81\xd2\x1d\x9ck\xab\x81r[\xbc\xb9\x83\xb6\x07\x97\xdcg\xad\xcc\xc4KL(\t\x84\xbf\xba3\xe8\x14\xd3P\xe3\xfc\xb6I\x87\xc5\x9d\xc8\x842\x96\x82\xca]\x84L\xact\x06\x01\x84\xc5\x07C\xaa\xd2jf\\\xe6\xc2\xd9\x04\xcc\xc0\xb0\xb1\xfe\x11J\xe0'\x0b\xdf\x16\x02\xd6\x1d\x9d2+\x90@1\xdd\xb2\xf8 O^\xfb\x7f-\x94\x1a"
# try:
#     result_str = result_bytes.decode('latin-1')
#     print(result_str)
# except UnicodeDecodeError:
#     print("latin-1编码也无法解码，继续尝试其他编码")
#
#
# result_bytes = b"&D\xc6\x0b\xbb!\x04K\xb0\xf1\xde\xeb\xbaF\ne\x95&\xf7\x96)=\x8a/;\x19\xe3\xd9\xee\x9a\xe6\x81\xd2\x1d\x9ck\xab\x81r[\xbc\xb9\x83\xb6\x07\x97\xdcg\xad\xcc\xc4KL(\t\x84\xbf\xba3\xe8\x14\xd3P\xe3\xfc\xb6I\x87\xc5\x9d\xc8\x842\x96\x82\xca]\x84L\xact\x06\x01\x84\xc5\x07C\xaa\xd2jf\\\xe6\xc2\xd9\x04\xcc\xc0\xb0\xb1\xfe\x11J\xe0'\x0b\xdf\x16\x02\xd6\x1d\x9d2+\x90@1\xdd\xb2\xf8 O^\xfb\x7f-\x94\x1a"
# try:
#     result_str = result_bytes.decode('GBK')
#     print(result_str)
# except UnicodeDecodeError:
#     print("GBK编码也无法解码，继续尝试其他编码")
#
# result_bytes = b"&D\xc6\x0b\xbb!\x04K\xb0\xf1\xde\xeb\xbaF\ne\x95&\xf7\x96)=\x8a/;\x19\xe3\xd9\xee\x9a\xe6\x81\xd2\x1d\x9ck\xab\x81r[\xbc\xb9\x83\xb6\x07\x97\xdcg\xad\xcc\xc4KL(\t\x84\xbf\xba3\xe8\x14\xd3P\xe3\xfc\xb6I\x87\xc5\x9d\xc8\x842\x96\x82\xca]\x84L\xact\x06\x01\x84\xc5\x07C\xaa\xd2jf\\\xe6\xc2\xd9\x04\xcc\xc0\xb0\xb1\xfe\x11J\xe0'\x0b\xdf\x16\x02\xd6\x1d\x9d2+\x90@1\xdd\xb2\xf8 O^\xfb\x7f-\x94\x1a"
# try:
#     result_str = result_bytes.decode('ISO-8859-1')
#     print(result_str)
# except UnicodeDecodeError:
#     print("ISO-8859-1编码也无法解码，可能需要更深入分析字节串的来源和编码情况")

# from Crypto.Util.number import long_to_bytes
# from gmpy2 import is_prime
#
# # 题目给出的值
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 穷举随机数范围尝试计算p
# for r in range(e, 2 * e + 1):
#     p_candidate = (hint - e) ^ r
#     if is_prime(p_candidate) and n % p_candidate == 0:
#         p = p_candidate
#         break
#
# q = n // p
# phi = (p - 1) * (q - 1)
# # 计算私钥指数d（这里假设已经有合适的函数实现扩展欧几里得算法求模逆）
# d = inverse(e, phi)
# m = pow(c, d, n)
# print(long_to_bytes(m))

# from Crypto.Util.number import long_to_bytes
# from gmpy2 import is_prime, invert
#
# # 题目给出的值
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 穷举随机数范围尝试计算p
# p = None
# for r in range(e, 2 * e + 1):
#     p_candidate = (hint - e) ^ r
#     if is_prime(p_candidate) and n % p_candidate == 0:
#         p = p_candidate
#         break
#
# if p is None:
#     print("未能成功找到合适的p值，请检查题目信息或算法逻辑")
# else:
#     q = n // p
#     phi = (p - 1) * (q - 1)
#     # 计算私钥指数d
#     d = invert(e, phi)
#     m = pow(c, d, n)
#     print(long_to_bytes(m))


# from Crypto.Util.number import long_to_bytes
# from gmpy2 import is_prime, invert
# import random
#
# # 题目给出的值
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 适当扩大穷举范围，可根据实际情况再调整范围大小
# extended_range = range(e - 1000, 2 * e + 1000)
# p = None
# for r in extended_range:
#     p_candidate = (hint - e) ^ r
#     # 增加额外的素数判断验证逻辑，这里使用简单的试除法辅助验证（效率较低但可辅助检查）
#     def simple_is_prime(num):
#         if num < 2:
#             return False
#         for i in range(2, int(num ** 0.5) + 1):
#             if num % i == 0:
#                 return False
#         return True
#     if is_prime(p_candidate) and simple_is_prime(p_candidate) and n % p_candidate == 0:
#         p = p_candidate
#         break
#
# if p is None:
#     print("仍然未能成功找到合适的p值，请进一步检查题目信息或算法逻辑")
# else:
#     q = n // p
#     phi = (p - 1) * (q - 1)
#     # 计算私钥指数d
#     d = invert(e, phi)
#     m = pow(c, d, n)
#     print(long_to_bytes(m))



# from Crypto.Util.number import *
# from gmpy2 import *
# import random
#
# flag = b'FLAG{xxxxxxxxxxxxxxxxxxxxxxxxxx}'
#
# m = bytes_to_long(flag)
#
# p = getPrime(512)
# q = getPrime(512)
# n = p * q
# e = 65537
#
# hint = e + p ^ random.randint(e, 2 * e)
#
# c = pow(m, e, n)
#
# print(f'c={c}')
# print(f'hint={hint}')
# print(f'n={n}')
# print(f'e={e}')


# from Crypto.Util.number import *
# from gmpy2 import *
#
# # 给定题目输出的已知值
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 在可能的随机数范围里遍历尝试
# for r in range(e, 2 * e + 1):
#     p_candidate = hint ^ r - e
#     if n % p_candidate == 0:
#         p = p_candidate
#         q = n // p
#         phi = (p - 1) * (q - 1)
#         d = invert(e, phi)  # 计算私钥d
#         m = pow(c, d, n)
#         print(long_to_bytes(m))
#         break


# from Crypto.Util.number import *
# from gmpy2 import *
#
#
# def main():
#     # 给定题目输出的已知值
#     c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
#     hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
#     n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
#     e = 65537
#
#     # 在可能的随机数范围里遍历尝试
#     for r in range(e, 2 * e + 1):
#         p_candidate = hint ^ r - e
#         print(f"尝试的p_candidate值为: {p_candidate}")
#         if n % p_candidate == 0:
#             print(f"找到合适的p_candidate: {p_candidate}")
#             p = p_candidate
#             q = n // p
#             phi = (p - 1) * (q - 1)
#             print(f"计算出的phi值为: {phi}")
#             try:
#                 d = invert(e, phi)
#                 print(f"计算出的私钥d值为: {d}")
#                 m = pow(c, d, n)
#                 result = long_to_bytes(m)
#                 print(f"解密得到的结果为: {result}")
#                 return result
#             except Exception as err:
#                 print(f"在计算私钥或解密过程中出现错误: {err}")
#     print("在给定的r取值范围内，未找到合适的p值，请检查题目参数或逻辑")
#     return None
#
#
# if __name__ == "__main__":
#     flag = main()
#     if flag:
#         print(f"最终的flag为: {flag.decode('utf-8') if isinstance(flag, bytes) else flag}")
#     else:
#         print("未能成功获取flag，请根据上述提示排查问题")



# # 设定一个大概的范围界限来暴力尝试，这里的界限只是示例，要结合实际情况和计算资源考虑
# lower_bound = 2 ** 511
# upper_bound = 2 ** 512 - 1
# for p_try in range(lower_bound, upper_bound):
#     if isPrime(p_try):
#         for q_try in range(lower_bound, upper_bound):
#             if isPrime(q_try):
#                 n_try = p_try * q_try
#                 if n_try == n:
#                     p = p_try
#                     q = q_try
#                     phi = (p - 1) * (q - 1)
#                     d = invert(e, phi)
#                     m = pow(c, d, n)
#                     print(long_to_bytes(m))
#                     return
# print("通过暴力破解方式未能找到合适的p和q，请考虑其他更有效的方法")

# import rsa
#
# # 假设这里从题目中解析出合适的公钥、私钥等信息来加载
# with open('private.pem', 'rb') as privatefile:
#     private_key = rsa.PrivateKey.load_pkcs1(privatefile.read())
#
# ciphertext = 'mMl10Qb563DkqTHdY69mWFHSRwfAqyspyEL0RSkxB3WxIatapBAV63inYoP/dBaR'
# # 要先将密文处理为合适的字节类型等，假设已经处理好了，叫ciphertext_bytes
# decrypted_text = rsa.decrypt(ciphertext_bytes, private_key)
# print(decrypted_text.decode('utf-8'))


# from Crypto.Cipher import AES
#
# key = bytes.fromhex('0f234c118bf7')  # 将十六进制格式的密钥转换为字节类型，这里假设密钥是十六进制表示，需按实际调整
# ciphertext = 'mMl10Qb563DkqTHdY69mWFHSRwfAqyspyEL0RSkxB3WxIatapBAV63inYoP/dBaR'
# cipher = AES.new(key, AES.MODE_ECB)  # 假设是ECB模式，要根据实际情况修改
# decrypted_text = cipher.decrypt(ciphertext)
# print(decrypted_text.decode('utf-8'))

# from Crypto.Util.number import *
# from gmpy2 import *
# import random
#
# # 从题目输出中获取已知值
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 尝试找出p
# for r in range(e, 2 * e + 1):
#     candidate_p = hint ^ r - e
#     if isPrime(candidate_p):
#         p = candidate_p
#         break
#
# # 计算q
# q = n // p
#
# # 计算私钥指数d
# d = invert(e, (p - 1) * (q - 1))
#
# # 解密得到消息m
# m = pow(c, d, n)
#
# # 将消息转换回字节类型得到flag
# flag = long_to_bytes(m)
# print(flag.decode('utf-8'))
#

# from Crypto.Util.number import *
# from gmpy2 import *
# import random
#
# # 从题目输出中获取已知值
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 尝试找出p
# for r in range(e, 2 * e + 1):
#     candidate_p = hint ^ r - e
#     if isPrime(candidate_p):
#         p = candidate_p
#         break
#
# # 计算q
# q = n // p
#
# # 计算私钥指数d
# d = invert(e, (p - 1) * (q - 1))
#
# # 解密得到消息m
# m = pow(c, d, n)
#
# # 将消息转换回字节类型
# flag_bytes = long_to_bytes(m)
#
# # 尝试多种编码方式进行解码
# encodings = ['utf-8', 'latin-1', 'ascii', 'gbk', 'big5']  # 这里列举了一些常见编码，可根据实际情况调整
# for encoding in encodings:
#     try:
#         flag = flag_bytes.decode(encoding)
#         print(f"使用 {encoding} 编码解码成功，flag为: {flag}")
#         break
#     except UnicodeDecodeError:
#         continue
# else:
#     print("尝试了多种常见编码方式，均无法解码，可能需要进一步分析数据")


# import base64
#
# flag_latin1 = "&DÆ»!K°ñÞëºF e&÷)=/;ãÙîæÒk«r[¼¹¶Üg­ÌÄKL(	¿º3èÓPãü¶IÅÈ2Ê]L¬tÅCªÒjf\æÂÙÌÀ°±þJà'ßÖ2+@1Ý²ø O^û-"
# try:
#     flag_base64_decoded = base64.b64decode(flag_latin1)
#     print(flag_base64_decoded.decode('latin-1'))  # 这里先假设解码后还是latin-1能解码，可按需调整尝试其他编码
# except:
#     print("可能不是Base64编码或者解码出现问题")

# flag = "&DÆ»!K°ñÞëºF e&÷)=/;ãÙîæÒk«r[¼¹¶Üg­ÌÄKL(	¿º3èÓPãü¶IÅÈ2Ê]L¬tÅCªÒjf\æÂÙÌÀ°±þJà'ßÖ2+@1Ý²ø O^û-"
# for char in flag:
#     print(ord(char), char)

from Crypto.Util.number import long_to_bytes, isPrime
from gmpy2 import invert

# 已知的加密结果信息
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
#
# def try_crack():
#     for r in range(e, 2 * e + 1):
#         possible_p = hint ^ r - e
#         if possible_p > 0:
#             if n % possible_p == 0:
#                 possible_q = n // possible_p
#                 if isPrime(possible_p) and isPrime(possible_q):  # 验证p和q是否都是素数
#                     phi = (possible_p - 1) * (possible_q - 1)
#                     try:
#                         d = invert(e, phi)
#                         m = pow(c, d, n)
#                         print(f"可能解密成功，解密后的消息（字节形式）: {long_to_bytes(m)}")
#                         return
#                     except:
#                         continue
#     print("未能成功破解，尝试的范围中未找到合适的p和q值。")
#
#
# if __name__ == "__main__":
#     try_crack()
#
# # 2.
# from Crypto.Util.number import long_to_bytes, isPrime
# from gmpy2 import invert
# import math
#
# # 已知的加密结果信息
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
#
# def try_crack():
#     for r in range(e, 2 * e + 1):
#         possible_p = hint ^ r - e
#         if possible_p > 0:
#             if n % possible_p == 0:
#                 possible_q = n // possible_p
#                 if isPrime(possible_p) and isPrime(possible_q):
#                     phi = (possible_p - 1) * (possible_q - 1)
#                     if math.gcd(e, phi) == 1:  # 额外判断e和phi是否互素，确保能求逆得到d
#                         try:
#                             d = invert(e, phi)
#                             m = pow(c, d, n)
#                             print(f"可能解密成功，解密后的消息（字节形式）: {long_to_bytes(m)}")
#                             return
#                         except:
#                             continue
#     print("未能成功破解，尝试的范围中未找到合适的p和q值。")
#
#
# if __name__ == "__main__":
#     try_crack()
#

# from Crypto.Util.number import long_to_bytes, isPrime
# from gmpy2 import invert, gcd
# import math
#
#
# # 已知的加密结果信息
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
#
# def try_crack():
#     max_iterations = 100000  # 设置一个最大尝试次数，避免无限循环
#     iteration_count = 0
#     for r in range(e, 2 * e + 1):
#         if iteration_count >= max_iterations:
#             break
#         possible_p = hint ^ r - e
#         if possible_p > 0:
#             if n % possible_p == 0:
#                 possible_q = n // possible_p
#                 if isPrime(possible_p) and isPrime(possible_q):
#                     phi = (possible_p - 1) * (possible_q - 1)
#                     if gcd(e, phi) == 1:
#                         try:
#                             d = invert(e, phi)
#                             m = pow(c, d, n)
#                             print(f"可能解密成功，解密后的消息（字节形式）: {long_to_bytes(m)}")
#                             return
#                         except:
#                             continue
#         iteration_count += 1
#     print("未能成功破解，尝试的范围中未找到合适的p和q值。")
#
#
# if __name__ == "__main__":
#     try_crack()
#

# from Crypto.Util.number import long_to_bytes, isPrime
# from gmpy2 import invert, gcd
# import math
#
# # 已知的加密结果信息
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 用于记录 (p ^ r) % e 的结果及其出现次数的字典
# result_count_dict = {}
# for r in range(e, 2 * e + 1):
#     result = (hint ^ r - e) % e
#     if result in result_count_dict:
#         result_count_dict[result] += 1
#     else:
#         result_count_dict[result] = 1
#
# # 分析字典中出现次数较多等有特征的结果，这里简单打印出来观察
# for result, count in result_count_dict.items():
#     print(f"结果 {result} 出现次数: {count}")
#
# # 后续可以结合这些分析结果进一步尝试寻找p，例如优先尝试对应结果出现次数多的情况去验证能否整除n等操作

# from Crypto.Util.number import long_to_bytes, isPrime
# from gmpy2 import invert, gcd
# import math
#
# # 已知的加密结果信息（此处省略重复代码，和上面一样）
#
# def check_fermat(possible_p):
#     for a in [2, 3, 5, 7]:  # 选取几个较小的素数作为a进行验证
#         if pow(a, possible_p - 1, possible_p)!= 1:
#             return False
#     return True
#
# for r in range(e, 2 * e + 1):
#     possible_p = hint ^ r - e
#     if possible_p > 0:
#         if n % possible_p == 0:
#             possible_q = n // possible_p
#             if isPrime(possible_p) and isPrime(possible_q):
#                 if check_fermat(possible_p):  # 增加费马小定理验证
#                     phi = (possible_p - 1) * (possible_q - 1)
#                     if gcd(e, phi) == 1:
#                         try:
#                             d = invert(e, phi)
#                             m = pow(c, d, n)
#                             print(f"可能解密成功，解密后的消息（字节形式）: {long_to_bytes(m)}")
#                             return
#                         except:
#                             continue
# print("未能成功破解，尝试的范围中未找到合适的p和q值。")
#
#
# from Crypto.Util.number import long_to_bytes
# from gmpy2 import invert
# import random
#
# # 已知信息
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 适当扩大穷举范围，可根据实际情况进一步合理调整
# start_range = max(0, e - 10000)
# end_range = 2 * e + 10000
# found = False
# for r in range(start_range, end_range):
#     candidate_p = hint ^ r ^ e
#     if candidate_p < 2 ** 512 and candidate_p > 1 and n % candidate_p == 0:  # 增加判断条件，确保候选p符合素数的大致范围且能整除n
#         p = candidate_p
#         q = n // p
#         print("找到p:", p)
#         print("找到q:", q)
#         found = True
#         break
#
# if not found:
#     print("经过多次尝试，仍未能找到合适的p和q，无法继续解密。")
# else:
#     # 计算私钥d
#     phi = (p - 1) * (q - 1)
#     d = invert(e, phi)
#
#     # 解密
#     m = pow(c, d, n)
#     print("解密后的消息（长整型）:", m)
#     flag = long_to_bytes(m)
#     print("解密后的flag:", flag)
#
#
# from Crypto.Util.number import *
# from gmpy2 import *
# import random
#
# flag = b'FLAG{xxxxxxxxxxxxxxxxxxxxxxxxxx}'
#
# m = bytes_to_long(flag)
#
# p = getPrime(512)
# q = getPrime(512)
# n = p * q
# e = 65537
#
# hint = e + p ^ random.randint(e, 2 * e)
#
# c = pow(m, e, n)
#
#
# print(f'c={c}')
# print(f'hint={hint}')
# print(f'n={n}')
# print(f'e={e}')
#
# from Crypto.Util.number import long_to_bytes
# from gmpy2 import invert
# import random
#
# # 第一组数据
# c1 = 118525098751258430551969056815423382091698882172200463493435624702036157369271740999866795859471240158308340711820481210871884503102450393064465151277544541510307828484975157882266888871288416315516983732363606606117516460574870782252525921716758447300144568237906073913160687753833331759302011199317244925568
# hint1 = 11616970821104597914604734113802232303349069702048280062346612350171373026167160393764702071844315695025455832359165232797205419651124387130012701878861941
# n1 = 123301362419985853115904585927706957121630955946799611104594451387810234236421551250503146540055451491268381781209192320213867747820322054470200377916962905993685264592068325646973340326377976902804492098942361788879269474617226339463321001293828671319070202477211666247605854785895118132943638776168301841591
# e1 = 65537
#
# # 第二组数据（你之前也提供过的那组，一并处理方便对比等情况，可根据实际需求调整）
# c2 = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint2 = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n2 = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e2 = 65537
#
# # 处理第一组数据
# found1 = False
# # 适当扩大穷举范围，可根据实际情况进一步合理调整
# start_range1 = max(0, e1 - 10000)
# end_range1 = 2 * e1 + 10000
# for r1 in range(start_range1, end_range1):
#     candidate_p1 = hint1 ^ r1 ^ e1
#     if candidate_p1 < 2 ** 512 and candidate_p1 > 1 and n1 % candidate_p1 == 0:  # 增加判断条件，确保候选p符合素数的大致范围且能整除n
#         p1 = candidate_p1
#         q1 = n1 // p1
#         print("第一组数据找到p:", p1)
#         print("第一组数据找到q:", q1)
#         found1 = True
#         break
#
# if not found1:
#     print("第一组数据经过多次尝试，仍未能找到合适的p和q，无法继续解密。")
# else:
#     # 计算第一组数据私钥d1
#     phi1 = (p1 - 1) * (q1 - 1)
#     d1 = invert(e1, phi1)
#
#     # 解密第一组数据
#     m1 = pow(c1, d1, n1)
#     print("第一组数据解密后的消息（长整型）:", m1)
#     flag1 = long_to_bytes(m1)
#     print("第一组数据解密后的flag:", flag1)
#
# # 处理第二组数据
# found2 = False
# start_range2 = max(0, e2 - 10000)
# end_range2 = 2 * e2 + 10000
# for r2 in range(start_range2, end_range2):
#     candidate_p2 = hint2 ^ r2 ^ e2
#     if candidate_p2 < 2 ** 512 and candidate_p2 > 1 and n2 % candidate_p2 == 0:  # 增加判断条件，确保候选p符合素数的大致范围且能整除n
#         p2 = candidate_p2
#         q2 = n2 // p2
#         print("第二组数据找到p:", p2)
#         print("第二组数据找到q:", q2)
#         found2 = True
#         break
#
# if not found2:
#     print("第二组数据经过多次尝试，仍未能找到合适的p和q，无法继续解密。")
# else:
#     # 计算第二组数据私钥d2
#     phi2 = (p2 - 1) * (q2 - 1)
#     d2 = invert(e2, phi2)
#
#     # 解密第二组数据
#     m2 = pow(c2, d2, n2)
#     print("第二组数据解密后的消息（长整型）:", m2)
#     flag2 = long_to_bytes(m2)
#     print("第二组数据解密后的flag:", flag2)

# from Crypto.Util.number import long_to_bytes
# from gmpy2 import invert
# import random
#
# # 以之前提供的第二组数据为例（你可以根据实际需求切换为第一组等数据）
# c = 69891006146675664206616793901841838912258807858495882290800382069836071218778247025972602194399289898956436034879958077551431692369124044132637634573495642570358923026884838096517149082313481538456936115041173161270006582925387112403675956329254672943731294539357242395082073059647829315222573262870642137482
# hint = 11082470394881201444519563591838446192430412376428076494240245778753542229765917560013785726665082910454953668081281765705428205468789552851887791973931841
# n = 94142498644861936123135564015035482408123019489838532172050374105172892277003287161650278048715366990980817535269053462601446777089132532355298503311995244830457696959098572507790906254718347336557959969780988247745592605214416901623889783546304059718808888904342478663983369733765202903087728980341924407299
# e = 65537
#
# # 更精细的穷举及条件判断
# found = False
# start_range = max(0, e - 100000)  # 进一步扩大且可调整范围
# end_range = 2 * e + 100000
# for r in range(start_range, end_range):
#     candidate_p = hint ^ r ^ e
#     # 增加更多关于素数特征的判断条件，这里简单用一些基本的素数判断思路示例，可优化完善
#     if candidate_p < 2 ** 512 and candidate_p > 1 and n % candidate_p == 0 and is_prime(candidate_p):  # 假设存在is_prime函数判断素数，实际需导入相关库实现更准确判断
#         p = candidate_p
#         q = n // p
#         print("找到p:", p)
#         print("找到q:", q)
#         found = True
#         break
#
# if not found:
#     print("经过多次尝试，仍未能找到合适的p和q，无法继续解密。")
# else:
#     # 计算私钥d
#     phi = (p - 1) * (q - 1)
#     d = invert(e, phi)
#
#     # 解密
#     m = pow(c, d, n)
#     print("解密后的消息（长整型）:", m)
#     flag = long_to_bytes(m)
#     print("解密后的flag:", flag)

    # # 假设奇怪的flag内容是经过额外异或混淆后的结果，这里尝试简单的逆向异或破解思路
    # strange_flag = "&DÆ»!K°ñÞëºF e&÷)=/;ãÙîæÒk«r[¼¹¶ Üg­ÌÄKL(	¿º3èÓPãü¶IÅÈ2Ê]L¬tÅ CªÒjf\æÂÙÌÀ°±þJà' ßÖ2+@1Ý²ø O^û-"
    # # 尝试常见的可打印ASCII码范围字符作为异或密钥进行测试
    # for ascii_char in range(32, 127):  # 可打印字符范围
    #     recovered = ""
    #     for char in strange_flag:
    #         recovered += chr(ord(char) ^ ascii_char)
    #     print(f"尝试异或密钥 {chr(ascii_char)} 后的结果: {recovered}")

# from pycipher import Vigenere
#
# # 提取密钥中的字母部分（假设其是维吉尼亚密码关键词相关内容，这里简单处理示例）
# key = "0f23-4c11-8bf7"
# key_letters = "".join(filter(str.isalpha, key))
#
# cipher_text = "mMl10Qb563DkqTHdY69mWFHSRwfAqyspyEL0RSkxB3WxIatapBAV63inYoP/dBaR"
# try:
#     plain_text = Vigenere(key_letters).decrypt(cipher_text)
#     print(plain_text)
# except:
#     print("维吉尼亚密码解密失败，可能假设错误或者密钥等处理不当")
#
#     from Crypto.Cipher import AES
#     import base64
#
#     # 假设密文是经过Base64编码的，先进行解码（实际情况需根据题目判断）
#     cipher_text = base64.b64decode("mMl10Qb563DkqTHdY69mWFHSRwfAqyspyEL0RSkxB3WxIatapBAV63inYoP/dBaR")
#
#     # 处理密钥，去除连接符并转换为字节类型（根据实际情况调整，可能需要更多合适处理）
#     key = "0f23-4c11-8bf7".replace("-", "").encode('utf-8')
#
#     # 尝试AES的ECB模式解密（先尝试这种常见模式，实际可能需尝试多种模式）
#     cipher = AES.new(key, AES.MODE_ECB)
#     try:
#         plain_text = cipher.decrypt(cipher_text)
#         print(plain_text.decode('utf-8', errors='ignore'))
#     except:
#         print("AES ECB模式解密失败，可能密文格式、密钥处理或者实际不是此模式问题")
#
#     from Crypto.Cipher import AES
#     import base64
#
#     # 假设密文是经过Base64编码的，先进行解码（实际情况需根据题目判断）
#     cipher_text = base64.b64decode("mMl10Qb563DkqTHdY69mWFHSRwfAqyspyEL0RSkxB3WxIatapBAV63inYoP/dBaR")
#
#     # 处理密钥，去除连接符并转换为字节类型（根据实际情况调整，可能需要更多合适处理）
#     key = "0f23-4c11-8bf7".replace("-", "").encode('utf-8')
#
#     # 尝试AES的ECB模式解密（先尝试这种常见模式，实际可能需尝试多种模式）
#     cipher = AES.new(key, AES.MODE_ECB)
#     try:
#         plain_text = cipher.decrypt(cipher_text)
#         print(plain_text.decode('utf-8', errors='ignore'))
#     except:
#         print("AES ECB模式解密失败，可能密文格式、密钥处理或者实际不是此模式问题")

    # 可以继续添加代码尝试AES的其他模式，比如CBC模式等，需要额外处理初始向量等相关内容，示例如下（以下代码仅是示意，实际完整准确应用还需更多细节处理）
    # from Crypto.Util.Padding import unpad
    # iv = b'\x00' * 16  # 假设初始向量，实际需根据题目判断获取正确值
    # cipher = AES.new(key, AES.MODE_CBC, iv)
    # try:
    #     plain_text = unpad(cipher.decrypt(cipher_text), AES.block_size)
    #     print(plain_text.decode('utf-8', errors='ignore'))
    # except:
    #     print("AES CBC模式解密失败，可能初始向量等设置有误或者其他问题")

# from Crypto.Cipher import AES
# import base64
#
# # 假设密文是经过Base64编码的，先进行解码（实际情况需根据题目判断）
# cipher_text = base64.b64decode("mMl10Qb563DkqTHdY69mWFHSRwfAqyspyEL0RSkxB3WxIatapBAV63inYoP/dBaR")
#
# # 处理密钥，去除连接符并转换为字节类型（根据实际情况调整，可能需要更多合适处理）
# key = "0f23-4c11-8bf7".replace("-", "").encode('utf-8')
#
# # 尝试AES的ECB模式解密（先尝试这种常见模式，实际可能需尝试多种模式）
# cipher = AES.new(key, AES.MODE_ECB)
# try:
#     plain_text = cipher.decrypt(cipher_text)
#     print(plain_text.decode('utf-8', errors='ignore'))
# except:
#     print("AES ECB模式解密失败，可能密文格式、密钥处理或者实际不是此模式问题")

# 可以继续添加代码尝试AES的其他模式，比如CBC模式等，需要额外处理初始向量等相关内容，示例如下（以下代码仅是示意，实际完整准确应用还需更多细节处理）
# from Crypto.Util.Padding import unpad
# iv = b'\x00' * 16  # 假设初始向量，实际需根据题目判断获取正确值
# cipher = AES.new(key, AES.MODE_CBC, iv)
# try:
#     plain_text = unpad(cipher.decrypt(cipher_text), AES.block_size)
#     print(plain_text.decode('utf-8', errors='ignore'))
# except:
#     print("AES CBC模式解密失败，可能初始向量等设置有误或者其他问题")

# from Crypto.Cipher import DES
# import base64
#
# # 假设密文是经过Base64编码的，先进行解码（实际情况需根据题目判断）
# cipher_text = base64.b64decode("mMl10Qb563DkqTHdY69mWFHSRwfAqyspyEL0RSkxB3WxIatapBAV63inYoP/dBaR")
#
# # 处理密钥，去除连接符并转换为字节类型（根据实际情况调整，可能需要更多合适处理）
# key = "0f23-4c11-8bf7".replace("-", "").encode('utf-8')[:8]  # DES密钥长度为8字节，截取合适长度（需判断是否合理这样做）
#
# # 尝试DES的ECB模式解密（先尝试这种常见模式，实际可能需尝试多种模式）
# cipher = DES.new(key, DES.MODE_ECB)
# try:
#     plain_text = cipher.decrypt(cipher_text)
#     print(plain_text.decode('utf-8', errors='ignore'))
# except:
#     print("DES ECB模式解密失败，可能密文格式、密钥处理或者实际不是此模式问题")
#
# # 可以类似AES继续尝试DES的CBC等其他模式，添加对应代码进行操作，处理方式和思路与AES类似但注意DES自身特点，如块大小等的不同

# from Crypto.PublicKey.RSA import construct
#
# # 这里只是示意性的把密钥当作模数等相关值来构造（实际肯定不符合真实情况，仅展示代码结构思路）
# key = "0f23-4c11-8bf7"
# n = int(key, 16)  # 假设转换为整数作为模数（很可能不对，只是示例写法）
# e = 65537  # 常见公钥指数，实际需根据题目判断
#
# # 构造一个虚拟的公钥（很可能不符合实际，仅示意）
# key_rsa = construct((n, e))
#
# # 以下假设密文是整数形式（实际肯定不是这样简单，只是代码结构示例）
# cipher_text = "mMl10Qb563DkqTHdY69mWFHSRwfAqyspyEL0RSkxB3WxIatapBAV63inYoP/dBaR"
# c = int(cipher_text, 16)  # 假设转换为整数（错误假设，仅示例）
#
# # 尝试解密（肯定会失败，只是展示代码逻辑大概样子）
# try:
#     plain_text = key_rsa.decrypt(c)
#     print(plain_text)
# except:
#     print("RSA解密失败，因为前面的假设和处理基本都是不符合实际的，仅作代码结构示意")

# from Crypto.Cipher import DES
# import base64
# from Crypto.Util.Padding import unpad
#
# # 假设密文是经过Base64编码的，先进行解码（实际情况需根据题目判断）
# cipher_text = base64.b64decode("mMl10Qb563DkqTHdY69mWFHSRwfAqyspyEL0RSkxB3WxIatapBAV63inYoP/dBaR")
#
# # 处理密钥，去除连接符并转换为字节类型（根据实际情况调整，可能需要更多合适处理）
# key = "0f23-4c11-8bf7".replace("-", "").encode('utf-8')[:8]  # DES密钥长度为8字节，截取合适长度（需判断是否合理这样做）
#
# # 假设初始向量（IV），这里简单示例用8个字节的全0值，实际需根据题目准确获取初始向量值
# iv = b'\x00' * 8
#
# # 尝试DES的CBC模式解密
# cipher = DES.new(key, DES.MODE_CBC, iv)
# try:
#     plain_text = unpad(cipher.decrypt(cipher_text), DES.block_size)
#     print(plain_text.decode('utf-8', errors='ignore'))
# except:
#     print("DES CBC模式解密失败，可能初始向量等设置有误或者其他问题")
